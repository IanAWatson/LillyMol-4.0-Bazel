// Use a database generated by generate_atom_separations to form
// new molecules based on matched atoms in an input stream

#include <fcntl.h>

#include <iostream>
#include <unordered_map>

#include "lmdb.h"

#include "google/protobuf/text_format.h"
#include "google/protobuf/io/zero_copy_stream_impl_lite.h"

#include "Foundational/cmdline/cmdline.h"
#include "Foundational/iwmisc/misc.h"

#include "Molecule_Lib/aromatic.h"
#include "Molecule_Lib/istream_and_type.h"
#include "Molecule_Lib/molecule.h"
#include "Molecule_Lib/qry_wstats.h"
#include "Molecule_Lib/rwsubstructure.h"
#include "Molecule_Lib/substructure.h"
#include "Molecule_Lib/standardise.h"
#include "Molecule_Lib/target.h"

#include "Molecule_Tools/atom_separations.h"
#include "Molecule_Tools/core_replacement_lib.h"
#include "Molecule_Tools/embedded_fragment.pb.h"

namespace separated_atoms {

using std::cerr;
using embedded_fragment::EmbeddedFragment;

void
Usage(int rc) {

  cerr << " -d <dbname>       database containing labelled cores (from generate_atom_separations)\n";
  cerr << " -q <qry>          queries that identify the break points\n";
  cerr << " -s <smarts>       smarts that identify the break points, [1].[1] or [1].[1].[1] for example\n"; 
  cerr << " -F <qry>          fragment must contain queries\n";
  cerr << " -f <smarts>       fragment must contain smarts\n";
  cerr << " -p <number>       minumum support level for replacement fragments\n";
  cerr << " -c                remove chirality\n";
  cerr << " -l                strip to largest fragment\n";
  cerr << " -g ...            chemical standardisation\n";
  cerr << " -A ...            standard aromaticity options\n";
  cerr << " -E ...            standard element options\n";
  cerr << " -v                verbose output\n";

  ::exit(rc);
}

class CoreReplacement {
  private:
    int _verbose;

    int _molecules_read;

    int _reduce_to_largest_fragment;

    int _remove_chirality;

    IWString _database_name;
    MDB_env* mdb_env;
    MDB_txn* mdb_txn;
    MDB_dbi mdb_dbi;

    // We keep track of how many times we lookup keys.
    std::unordered_map<uint32_t, int> _keys_looked_up;

    FileType _input_type;

    Chemical_Standardisation _chemical_standardisation;

    // One or more queries for identifying the core.
    // The intent is that molecules come with isotopic labels
    // and so these queries will be very simple.
    // The number of queries specified is the number of cut points.
    resizable_array_p<Substructure_Hit_Statistics> _queries;

    // We can specify conditions on the fragments inserted
    resizable_array_p<Substructure_Hit_Statistics> _fragment_must_contain;

    int _no_query_match;
    int _cannot_identify_core;

    int _bonds_to_break;
    int _ignore_molecules_not_matching_queries;
    int _write_molecules_not_matching_queries;

    int _no_db_match;

    uint32_t _min_support_needed;

    int _max_atoms_lost;
    int _max_atoms_gained;

    separated_atoms::Hasher _hasher;

  // Private functions

    int OpenDatabase();
    int HandleNoQueryMatch(Molecule& m, IWString_and_File_Descriptor& output);
    int Process(Molecule& m,
        const Set_of_Atoms& matched_atoms,
        IWString_and_File_Descriptor& output);
    int Process(Molecule& m,
                const int* to_be_removed,
                IWString_and_File_Descriptor& output);
    int Process(Molecule& m,
                const Set_of_Atoms& matched_atoms,
                const int* to_be_removed,
                IWString_and_File_Descriptor& output);
    int Process2(Molecule& m,
                 const Set_of_Atoms& matched_atoms,
                 const int* to_be_removed,
                 IWString_and_File_Descriptor& output);
    int Process2(Molecule& m,
                 const Set_of_Atoms& matched_atoms,
                 uint32_t hash,
                 const int* to_be_removed,
                 IWString_and_File_Descriptor& output);
    int Process3(Molecule& m,
                 const Set_of_Atoms& matched_atoms,
                 const int* to_be_removed,
                 IWString_and_File_Descriptor& output);
    int DoReplacement2(Molecule& m,
                       const Set_of_Atoms& matched_atoms,
                       const embedded_fragment::EmbeddedFragment& fragment,
                       const int * to_be_removed,
                       IWString_and_File_Descriptor& output);
    int MeetsSupportRequirement(const EmbeddedFragment& fragment);
    int FragmentContainsNeededSubstructure(Molecule& m);
    int OkAtomCount(int number_atoms_removed, const Molecule& fragment);

  public:
    CoreReplacement();

    int Initialise(Command_Line& cl);

    int Preprocess(Molecule& m);

    int Process(Molecule& m, IWString_and_File_Descriptor& output);

    int Report(std::ostream& output) const;

    FileType input_type() const {
      return _input_type;
    }
};

CoreReplacement::CoreReplacement() {
  _verbose = 0;
  _molecules_read = 0;
  _reduce_to_largest_fragment = 0;
  _remove_chirality = 0;
  _input_type = FILE_TYPE_INVALID;
  _bonds_to_break = 0;
  _no_query_match = 0;
  _cannot_identify_core = 0;
  _ignore_molecules_not_matching_queries = 0;
  _write_molecules_not_matching_queries = 0;
  _no_db_match = 0;
  _min_support_needed = 0;

  mdb_env = nullptr;
  mdb_txn = nullptr;
  mdb_dbi = 0;
}

int
CoreReplacement::OpenDatabase() {
  int status =  mdb_env_create(&mdb_env);
  if (status != 0) {
    cerr << "CoreReplacement::OpenDatabase:cannot create environment, status " << status << '\n';
    return 0;
  }


  unsigned int flags = MDB_RDONLY;
  mdb_mode_t mode = O_RDONLY | MDB_NOLOCK;

  status = mdb_env_open(mdb_env, _database_name.null_terminated_chars(), flags, mode);
  if (status != 0) {
    cerr << "CoreReplacement::OpenDatabase:cannot open environment '" << _database_name << " status " << status << '\n';
    return 0;
  }

  if (auto status = mdb_txn_begin(mdb_env, NULL /*parent*/, flags, &mdb_txn);
      status != 0) {
    cerr << "CoreReplacement::OpenDatabase:cannot begin transaction " << status << '\n';
    return 0;
  }

  if (auto status = mdb_dbi_open(mdb_txn, NULL, 0, &mdb_dbi);
      status != 0) {
    cerr << "CoreReplacement::OpenDatabase:mdb_dbi_open failed " << status << '\n';
    return 0;
  }

  return 1;
}

int
CoreReplacement::Initialise(Command_Line& cl) {
  _verbose = cl.option_count('v');

  if (cl.option_present('c')) {
    _remove_chirality = 1;
    if (_verbose) {
      cerr << "Will remove chirality from input molecules\n";
    }
  }

  if (cl.option_present('g')) {
    if (! _chemical_standardisation.construct_from_command_line(cl, _verbose, 'g')) {
      cerr << "Cannot initialise chemical standardisation\n";
      return 0;
    }
  }

  if (cl.option_present('l')) {
    _reduce_to_largest_fragment = 1;
    if (_verbose) {
      cerr << "Will reduce molecules to largest fragment\n";
    }
  }

  if (! cl.option_present('d')) {
    cerr << "Must specify database name via the -d option\n";
    return 0;
  }

  _database_name = cl.string_value('d');

  if (cl.option_present('q')) {
    if (! process_queries(cl, _queries, _verbose, 'q')) {
      cerr << "CoreReplacement::Initialise:cannot read queries (-q)\n";
      return 0;
    }
  }

  if (cl.option_present('s')) {
    const_IWSubstring smarts;
    for (int i = 0; cl.value('s', smarts, i); ++i) {
      std::unique_ptr<Substructure_Hit_Statistics> qry = std::make_unique<Substructure_Hit_Statistics>();
      if (! qry->create_from_smarts(smarts)) {
        cerr << "CoreReplacement::Initialise:cannot parse smarts '" << smarts << "'\n";
        return 0;
      }
      _queries << qry.release();
    }
  }

  for (Substructure_Hit_Statistics* q : _queries) {
    q->set_find_unique_embeddings_only(1);
  }

  if (cl.option_present('F')) {
    if (! process_queries(cl, _fragment_must_contain, _verbose, 'F')) {
      cerr << "CoreReplacement::Initialise:cannot read fragment must contain queries (-F)\n";
      return 0;
    }
  }

  if (_verbose) {
    cerr << "Definied " << _queries.size() << " break point queries\n";
  }

  if (_queries.empty()) {
    cerr << "CoreReplacement::Initialise:must specify one or more queries to replace via the -q and/or -s options\n";
    return 0;
  }

  if (cl.option_present('f')) {
    const_IWSubstring smarts;
    for (int i = 0; cl.value('f', smarts, i); ++i) {
      std::unique_ptr<Substructure_Hit_Statistics> qry = std::make_unique<Substructure_Hit_Statistics>();
      if (! qry->create_from_smarts(smarts)) {
        cerr << "CoreReplacement::Initialise:cannot parse smarts '" << smarts << "'\n";
        return 0;
      }
      _fragment_must_contain << qry.release();
    }
  }

  // These queries should be executed as quickly as possible.
  for (Substructure_Hit_Statistics* q : _fragment_must_contain) {
    q->set_max_matches_to_find(1);
    q->set_save_matched_atoms(0);
  }

  if (cl.option_present('p')) {
    if (! cl.value('p', _min_support_needed) || _min_support_needed < 1) {
      cerr << "CoreReplacement::Initialise:the support level (-p) must be positive\n";
      return 0;
    }

    if (_verbose) {
      cerr << "Will only use fragments seen " << _min_support_needed << " or more times\n";
    }
  }

  if (cl.option_present('z')) {
    const_IWSubstring z;
    for (int i = 0; cl.value('z', z, i); ++i) {
      if (z == 'i') {
        _ignore_molecules_not_matching_queries = 1;
      } else if (z == 'w') {
        _write_molecules_not_matching_queries = 1;
      } else {
        cerr << "Unrecognised -z qualifier '" << z << "'\n";
        return 0;
      }
    }
  }

  if (1 == cl.number_elements() && 0 == strcmp("-", cl[0])) { // reading a pipe, assume smiles
    _input_type = FILE_TYPE_SMI;
  } else if (!all_files_recognised_by_suffix(cl)) {
    cerr << "Cannot discern all file types, use the -i option\n";
    return 0;
  } else if (!process_input_type(cl, _input_type)) {
    return 0;
  }

  return OpenDatabase();
}

int
CoreReplacement::Preprocess(Molecule& m) {
  ++_molecules_read;

  if (_reduce_to_largest_fragment) {
    m.reduce_to_largest_fragment_carefully();
  }

  if (_chemical_standardisation.active()) {
    _chemical_standardisation.process(m);
  }

  if (_remove_chirality) {
    m.remove_all_chiral_centres();
  }

  if (m.natoms() == 0) {
    return 0;
  }

  return 1;
}

int
CoreReplacement::Process(Molecule& m,
                         IWString_and_File_Descriptor& output) {
  Molecule_to_Match target(&m);
  Substructure_Results sresults;
  Set_of_Atoms matched_atoms;
  for (Substructure_Hit_Statistics * q : _queries) {
    const int nhits = q->substructure_search(target, sresults);
    if (nhits == 0) {
      continue;
    }
    matched_atoms = *sresults.embedding(0);
    break;
  }

  if (matched_atoms.empty()) {
    cerr << "CoreReplacement::Process: no query matches to " << m.smiles() << ' ' << m.name() << '\n';
    return HandleNoQueryMatch(m, output);
  }

  return Process(m, matched_atoms, output);
}

// The matched atoms define atoms that are retained.
// The first task is to identify the atoms that are
// therefore to be removed/replaced.
int
CoreReplacement::Process(Molecule& m,
        const Set_of_Atoms& matched_atoms,
        IWString_and_File_Descriptor& output) {
  assert(matched_atoms.number_elements() == _bonds_to_break);

  const int matoms = m.natoms();
  std::unique_ptr<int[]> to_be_removed(new_int(matoms));
  if (! IdentifyAtomsToRemove(m, matched_atoms, to_be_removed.get())) {
    ++_cannot_identify_core;
    cerr << "No core\n";
    if (_verbose > 1) {
      cerr << "CoreReplacement::Process:cannot identify core in " << m.smiles() << '\n';
    }
    return 0;
  }

  return Process(m, matched_atoms, to_be_removed.get(), output);
}

int
CoreReplacement::Process(Molecule& m,
                         const Set_of_Atoms& matched_atoms,
                         const int* to_be_removed,
                         IWString_and_File_Descriptor& output) {
  cerr << " breaking " << _bonds_to_break << " bonds\n";
  if (matched_atoms.size() == 2) {
    return Process2(m, matched_atoms, to_be_removed, output);
  }

  if (matched_atoms.size() == 3) {
    return Process3(m, matched_atoms, to_be_removed, output);
  }

  cerr << "CoreReplacement::Process:do not know how to handle " << _bonds_to_break << " bonds broken\n";
  return 0;
}

int
CoreReplacement::Process2(Molecule& m,
                         const Set_of_Atoms& matched_atoms,
                          const int* to_be_removed,
                          IWString_and_File_Descriptor& output) {
  assert(matched_atoms.size() == 2);
  atom_number_t a1 = matched_atoms[0];
  atom_number_t a2 = matched_atoms[1];
  uint32_t hash = _hasher.Value(m.atomic_number(a1), m.atomic_number(a2), m.bonds_between(a1, a2));

  return Process2(m, matched_atoms, hash, to_be_removed, output);
}

int
CoreReplacement::Process2(Molecule& m,
                          const Set_of_Atoms& matched_atoms,
                          uint32_t hash,
                          const int* to_be_removed,
                          IWString_and_File_Descriptor& output) {
  MDB_val key;
  key.mv_data = &hash;
  key.mv_size = sizeof(hash);

  ++_keys_looked_up[hash];

  MDB_val value;
  cerr << "Looking up hash " << hash << '\n';
  if (int rc = mdb_get(mdb_txn, mdb_dbi, &key, &value);
      rc != 0) {
    ++_no_db_match;
    cerr << "Not in db\n";
    return 1;
  }

  int generated_this_molecule = 0;
  const const_IWSubstring buffer(reinterpret_cast<const char*>(value.mv_data), value.mv_size);
  const_IWSubstring line;
  int nlines = 0;
  for (int i = 0; buffer.nextword(line, i, '\n'); ++nlines) {
    embedded_fragment::EmbeddedFragment fragment;
    google::protobuf::io::ArrayInputStream zero_copy_array(line.data(), line.nchars());

    if (!google::protobuf::TextFormat::Parse(&zero_copy_array, &fragment)) {
      cerr << "CoreReplacement:Process2:cannot parse proto from db, key " << hash << '\n';
      cerr << line << '\n';
      return 0;
    }

    if (! DoReplacement2(m, matched_atoms, fragment, to_be_removed, output)) {
      cerr << "CoreReplacement::Process2:failure\n";
      return 0;
    }
    ++generated_this_molecule;
  }
  cerr << "Read " << nlines << " examples, size " << buffer.nchars() << '\n';

  return 1;
}

int
CoreReplacement::DoReplacement2(Molecule& m,
                                const Set_of_Atoms& matched_atoms,
                                const embedded_fragment::EmbeddedFragment& fragment,
                                const int * to_be_removed,
                                IWString_and_File_Descriptor& output) {
  if (! MeetsSupportRequirement(fragment)) {
    return 1;
  }

  Molecule frag;
  if (! frag.build_from_smiles(fragment.smiles())) {
    cerr << "CoreReplacement::DoReplacement2:cannot parse " << fragment.smiles() << '\n';
    return 1;
  }

  if (! FragmentContainsNeededSubstructure(frag)) {
    return 1;
  }

  const int matoms = m.natoms();
  int number_atoms_removed = std::count(to_be_removed, to_be_removed + matoms, 2);
  if (! OkAtomCount(number_atoms_removed, frag)) {
    return 0;
  }

  Molecule mcopy(m);
  mcopy.add_molecule(&frag);

  return 1;
}

int
CoreReplacement::Process3(Molecule& m,
                         const Set_of_Atoms& matched_atoms,
                          const int* to_be_removed,
                          IWString_and_File_Descriptor& output) {
  assert(matched_atoms.size() == 3);
  return 1;
}

int
CoreReplacement::FragmentContainsNeededSubstructure(Molecule& m) {
  if (_fragment_must_contain.empty()) {
    return 1;
  }

  Molecule_to_Match target(&m);
  for (Substructure_Hit_Statistics* q : _fragment_must_contain) {
    if (q->substructure_search(target)) {
      return 1;
    }
  }

  return 0;
}

int
CoreReplacement::OkAtomCount(int number_atoms_removed, const Molecule& fragment) {
  return 1;
}

int
CoreReplacement::HandleNoQueryMatch(Molecule& m,
                                    IWString_and_File_Descriptor& output) {
  ++_no_query_match;
  if (_ignore_molecules_not_matching_queries) {
    return 1;
  }

  if (_write_molecules_not_matching_queries) {
    output << m.smiles() << ' ' << m.name() << '\n';
    output.write_if_buffer_holds_more_than(8192);
    return 1;
  }

  return 0;
}

int
CoreReplacement::MeetsSupportRequirement(const EmbeddedFragment& fragment) {
  if (fragment.count() < _min_support_needed) {
    return 0;
  }
  return 1;
}

int
CoreReplacement::Report(std::ostream& output) const {
  output << "CoreReplacement:read " << _molecules_read << " molecules\n";
  if (_molecules_read == 0) {
    return 1;
  }

  output << _no_query_match << " molecules did not match any of " << _queries.size() << " queries\n";
  output << _cannot_identify_core << " could not identify core atoms (likely ring)\n";

  return 1;
}

int
ReplaceCore(CoreReplacement& core_replacement,
            Molecule& m,
            IWString_and_File_Descriptor& output) {
  return core_replacement.Process(m, output);
}

int
ReplaceCore(CoreReplacement& core_replacement,
            data_source_and_type<Molecule>& input,
            IWString_and_File_Descriptor& output) {
  Molecule * m;
  while ((m = input.next_molecule()) != nullptr) {
    std::unique_ptr<Molecule> free_m(m);

    if (! core_replacement.Preprocess(*m)) {
      return 0;
    }

    if (! ReplaceCore(core_replacement, *m, output)) {
      return 0;
    }
  }

  return 1;
}

int
ReplaceCore(CoreReplacement& core_replacement,
            const char * fname,
            IWString_and_File_Descriptor& output) {
  FileType input_type = core_replacement.input_type();
  if (input_type == FILE_TYPE_INVALID) {
    input_type = discern_file_type_from_name(fname);
  }

  data_source_and_type<Molecule> input(input_type, fname);
  if (! input.ok()) {
    cerr << "Cannot open '" << fname << "'\n";
    return 0;
  }

  return ReplaceCore(core_replacement, input, output);
}

int
Main(int argc, char** argv) {
  Command_Line cl(argc, argv, "vE:A:i:g:lcd:q:s:z:F:f:p:x:X:");
  if (cl.unrecognised_options_encountered()) {
    cerr << "unrecognised_options_encountered\n";
    Usage(1);
  }

  const int verbose = cl.option_count('v');

  if (! process_standard_aromaticity_options(cl, verbose, 'A')) {
    cerr << "Cannot process aromaticity options\n";
    return 1;
  }

  if (! process_elements(cl, verbose, 'E')) {
    cerr << "Cannot process standard elements options (-E)\n";
    return 1;
  }

  CoreReplacement core_replacement;
  if (! core_replacement.Initialise(cl)) {
    cerr << "Cannot initialise options\n";
    Usage(1);
  }

  if (cl.empty()) {
    cerr << "Insufficient arguments\n";
    Usage(1);
  }

  IWString_and_File_Descriptor output(1);
  for (const char* fname : cl) {
    if (! ReplaceCore(core_replacement, fname, output)) {
      cerr << "Fatal error processing '" << fname << "'\n";
      return 1;
    }
  }

  if (verbose) {
    core_replacement.Report(cerr);
  }

  return 0;
}

}  // namespace separated_atoms

int
main(int argc, char** argv) {
  int rc = separated_atoms::Main(argc, argv);

  return rc;
}
